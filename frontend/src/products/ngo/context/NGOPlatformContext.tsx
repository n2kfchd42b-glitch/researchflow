import React, { createContext, useContext, useState, useEffect } from 'react';

// --- Types ---

interface Program {
  id: string;
  name: string;
  country: string;
  donor: string;
  totalBudget: number;
  startDate: string;
  endDate: string;
  description: string;
  projectIds: string[];
  logoUrl: string | null;
}

interface Indicator {
  id: string;
  projectId: string;
  name: string;
  definition: string;
  datasetId: string;
  variable: string;
  calculationMethod: 'percentage' | 'mean' | 'ratio' | 'count' | 'sum' | 'median';
  disaggregateBy: string[];
  baselineValue: number | null;
  targetValue: number | null;
  currentValue: number | null;
  reportingFrequency: 'monthly' | 'quarterly' | 'semi-annual' | 'annual';
  trend: number[];
  lastUpdated: string;
}

interface DatasetVersion {
  version: number;
  label: string;
  timestamp: string;
  changes: string;
  rowCount: number;
  columnCount: number;
  snapshotKey: string;
}

interface ReportTemplate {
  id: string;
  type: 'baseline' | 'endline' | 'donor' | 'progress' | 'data-quality';
  projectId: string;
  generatedAt: string;
  sections: ReportSection[];
  format: 'pdf' | 'docx';
}

interface ReportSection {
  title: string;
  type: 'indicators' | 'charts' | 'dataset-summary' | 'methodology' | 'narrative' | 'budget' | 'timeline';
  content: string;
  autoGenerated: boolean;
}

interface DataQualityScore {
  overall: number;
  missing: number;
  duplicates: number;
  outliers: number;
  typeMismatches: number;
  suggestions: string[];
}

interface PlatformAlert {
  id: string;
  projectId: string;
  type: 'enrollment-behind' | 'no-data-upload' | 'ethics-expiring' | 'budget-overspend' | 'data-quality-low';
  severity: 'info' | 'warning' | 'critical';
  message: string;
  createdAt: string;
  dismissed: boolean;
  actionLabel: string;
  actionRoute: string;
}

type UserRole = 'program-manager' | 'data-analyst' | 'field-coordinator';

interface DataPipelineStage {
  stage: 'raw' | 'cleaning' | 'analysis-ready' | 'indicators' | 'reports';
  completedAt: string | null;
}

interface NGOState {
  programs: Program[];
  activeProgramId: string | null;
  indicators: Indicator[];
  datasetVersions: Record<string, DatasetVersion[]>;
  reportTemplates: ReportTemplate[];
  dataQualityScores: Record<string, DataQualityScore>;
  alerts: PlatformAlert[];
  userRole: UserRole;
  datasetPipelines: Record<string, DataPipelineStage[]>;
}

const defaultState: NGOState = {
  programs: [],
  activeProgramId: null,
  indicators: [],
  datasetVersions: {},
  reportTemplates: [],
  dataQualityScores: {},
  alerts: [],
  userRole: 'program-manager',
  datasetPipelines: {},
};

const STORAGE_KEY = 'rf_ngo_platform';

const NGOPlatformContext = createContext<any>(null);

export const NGOPlatformProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, setState] = useState<NGOState>(() => {
    const saved = localStorage.getItem(STORAGE_KEY);
    return saved ? JSON.parse(saved) : defaultState;
  });

  useEffect(() => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }, [state]);

  // --- Programs ---
  const createProgram = (program: Partial<Program>) => {
    const newProgram: Program = {
      ...program,
      id: program.id || Date.now().toString(),
      projectIds: program.projectIds || [],
      logoUrl: program.logoUrl || null,
      name: program.name || '',
      country: program.country || '',
      donor: program.donor || '',
      totalBudget: program.totalBudget || 0,
      startDate: program.startDate || '',
      endDate: program.endDate || '',
      description: program.description || '',
    } as Program;
    setState(s => ({ ...s, programs: [...s.programs, newProgram] }));
  };

  const updateProgram = (id: string, updates: Partial<Program>) => {
    setState(s => ({
      ...s,
      programs: s.programs.map(p => p.id === id ? { ...p, ...updates } : p),
    }));
  };

  const setActiveProgram = (id: string | null) => {
    setState(s => ({ ...s, activeProgramId: id }));
  };

  const addProjectToProgram = (programId: string, projectId: string) => {
    setState(s => ({
      ...s,
      programs: s.programs.map(p => p.id === programId ? { ...p, projectIds: [...p.projectIds, projectId] } : p),
    }));
  };

  // --- Indicators ---
  const createIndicator = (indicator: Partial<Indicator>) => {
    const newIndicator: Indicator = {
      ...indicator,
      id: indicator.id || Date.now().toString(),
      trend: indicator.trend || [],
      lastUpdated: new Date().toISOString(),
      name: indicator.name || '',
      definition: indicator.definition || '',
      datasetId: indicator.datasetId || '',
      variable: indicator.variable || '',
      calculationMethod: indicator.calculationMethod || 'count',
      disaggregateBy: indicator.disaggregateBy || [],
      baselineValue: indicator.baselineValue || null,
      targetValue: indicator.targetValue || null,
      currentValue: indicator.currentValue || null,
      reportingFrequency: indicator.reportingFrequency || 'annual',
      projectId: indicator.projectId || '',
    } as Indicator;
    setState(s => ({ ...s, indicators: [...s.indicators, newIndicator] }));
  };

  const updateIndicator = (id: string, updates: Partial<Indicator>) => {
    setState(s => ({
      ...s,
      indicators: s.indicators.map(i => i.id === id ? { ...i, ...updates } : i),
    }));
  };

  const deleteIndicator = (id: string) => {
    setState(s => ({
      ...s,
      indicators: s.indicators.filter(i => i.id !== id),
    }));
  };

  const recalculateIndicator = (id: string) => {
    // Mock calculation: random between baseline and target
    setState(s => ({
      ...s,
      indicators: s.indicators.map(i => {
        if (i.id === id && i.baselineValue !== null && i.targetValue !== null) {
          const value = Math.floor(
            i.baselineValue + Math.random() * (i.targetValue - i.baselineValue)
          );
          return {
            ...i,
            currentValue: value,
            trend: [...i.trend, value],
            lastUpdated: new Date().toISOString(),
          };
        }
        return i;
      }),
    }));
  };

  const getProjectIndicators = (projectId: string): Indicator[] => {
    return state.indicators.filter(i => i.projectId === projectId);
  };

  // --- Dataset Versioning ---
  const addDatasetVersion = (datasetId: string, version: DatasetVersion) => {
    setState(s => ({
      ...s,
      datasetVersions: {
        ...s.datasetVersions,
        [datasetId]: [...(s.datasetVersions[datasetId] || []), version],
      },
    }));
  };

  const restoreDatasetVersion = (datasetId: string, versionNumber: number) => {
    // Set active version to versionNumber (mock logic)
    setState(s => ({
      ...s,
      datasetVersions: {
        ...s.datasetVersions,
        [datasetId]: s.datasetVersions[datasetId].map(v => ({
          ...v,
          active: v.version === versionNumber,
        })),
      },
    }));
  };

  const getDatasetVersions = (datasetId: string): DatasetVersion[] => {
    return state.datasetVersions[datasetId] || [];
  };

  // --- Data Quality ---
  const calculateQualityScore = (datasetId: string, columns: any[]): DataQualityScore => {
    // Mock calculation
    const missing = columns.reduce((acc, col) => acc + (col.missing || 0), 0);
    const duplicates = 0;
    const outliers = 0;
    const typeMismatches = 0;
    const overall = Math.max(0, 100 - missing * 2);
    const suggestions = [
      missing > 0 ? `${missing} missing values detected` : '',
    ].filter(Boolean);
    return { overall, missing, duplicates, outliers, typeMismatches, suggestions };
  };

  const setDataQualityScore = (datasetId: string, score: DataQualityScore) => {
    setState(s => ({
      ...s,
      dataQualityScores: {
        ...s.dataQualityScores,
        [datasetId]: score,
      },
    }));
  };

  // --- Pipeline ---
  const updatePipelineStage = (datasetId: string, stage: string) => {
    if (!['raw', 'cleaning', 'analysis-ready', 'indicators', 'reports'].includes(stage)) return;
    setState(s => ({
      ...s,
      datasetPipelines: {
        ...s.datasetPipelines,
        [datasetId]: [
          ...(s.datasetPipelines[datasetId] || []),
          { stage: stage as DataPipelineStage['stage'], completedAt: new Date().toISOString() },
        ],
      },
    }));
  };

  const getDatasetPipeline = (datasetId: string): DataPipelineStage[] => {
    return state.datasetPipelines[datasetId] || [];
  };

  // --- Alerts ---
  const generateAlerts = (): PlatformAlert[] => {
    // Mock logic: return alerts from state
    return state.alerts;
  };

  const dismissAlert = (id: string) => {
    setState(s => ({
      ...s,
      alerts: s.alerts.map(a => a.id === id ? { ...a, dismissed: true } : a),
    }));
  };

  // --- Reports ---
  const generateReport = (template: Partial<ReportTemplate>): ReportTemplate => {
    const newReport: ReportTemplate = {
      ...template,
      id: template.id || Date.now().toString(),
      generatedAt: new Date().toISOString(),
      sections: template.sections || [],
      format: template.format || 'pdf',
      projectId: template.projectId || '',
      type: template.type || 'progress',
    } as ReportTemplate;
    setState(s => ({ ...s, reportTemplates: [...s.reportTemplates, newReport] }));
    return newReport;
  };

  // --- Role ---
  const setUserRole = (role: UserRole) => {
    setState(s => ({ ...s, userRole: role }));
  };

  return (
    <NGOPlatformContext.Provider
      value={{
        state,
        createProgram,
        updateProgram,
        setActiveProgram,
        addProjectToProgram,
        createIndicator,
        updateIndicator,
        deleteIndicator,
        recalculateIndicator,
        getProjectIndicators,
        addDatasetVersion,
        restoreDatasetVersion,
        getDatasetVersions,
        calculateQualityScore,
        setDataQualityScore,
        updatePipelineStage,
        getDatasetPipeline,
        generateAlerts,
        dismissAlert,
        generateReport,
        setUserRole,
      }}
    >
      {children}
    </NGOPlatformContext.Provider>
  );
};

export const useNGOPlatform = () => useContext(NGOPlatformContext);
