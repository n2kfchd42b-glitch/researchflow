import React, { useState } from 'react';

type VarInfo = {
  name:    string;
  type:    'numeric' | 'categorical' | 'binary' | 'text';
  values:  string[];
  missing: number;
  mean:    string;
  min:     string;
  max:     string;
};

function parseCSV(text: string) {
  const lines   = text.trim().split('\n');
  const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
  const rows    = lines.slice(1).map(line => {
    const vals = line.split(',');
    const obj: Record<string, string> = {};
    headers.forEach((h, i) => { obj[h] = (vals[i] || '').trim().replace(/"/g, ''); });
    return obj;
  });
  return { headers, rows };
}

function inferType(values: string[]): VarInfo['type'] {
  const nonEmpty = values.filter(v => v !== '' && v !== 'NA');
  const numeric  = nonEmpty.filter(v => !isNaN(parseFloat(v)));
  if (numeric.length / nonEmpty.length > 0.85) {
    return new Set(numeric).size <= 2 ? 'binary' : 'numeric';
  }
  return new Set(nonEmpty).size <= 10 ? 'categorical' : 'text';
}

function buildVarInfo(headers: string[], rows: Record<string, string>[]): VarInfo[] {
  return headers.map(col => {
    const allVals  = rows.map(r => r[col] || '');
    const nonEmpty = allVals.filter(v => v !== '' && v !== 'NA');
    const missing  = allVals.length - nonEmpty.length;
    const type     = inferType(nonEmpty);
    const numVals  = nonEmpty.map(v => parseFloat(v)).filter(v => !isNaN(v));
    const uniqueVals = Array.from(new Set(nonEmpty)).slice(0, 20);
    return {
      name:    col,
      type,
      values:  uniqueVals,
      missing,
      mean:    numVals.length > 0 ? (numVals.reduce((a,b)=>a+b,0)/numVals.length).toFixed(2) : '',
      min:     numVals.length > 0 ? Math.min(...numVals).toString() : '',
      max:     numVals.length > 0 ? Math.max(...numVals).toString() : '',
    };
  });
}

// â”€â”€ STATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateSTATA(vars: VarInfo[], filename: string, nRows: number): string {
  const numericVars     = vars.filter(v => v.type === 'numeric' || v.type === 'binary');
  const categoricalVars = vars.filter(v => v.type === 'categorical');
  const outcome         = vars[vars.length - 1];
  const predictors      = vars.slice(0, Math.min(5, vars.length - 1));

  return `/* ============================================================
   STATA DO FILE â€” Generated by ResearchFlow
   Dataset: ${filename}
   Observations: ${nRows}
   Variables: ${vars.length}
   Generated: ${new Date().toLocaleDateString()}
   ============================================================ */

version 17
clear all
set more off
capture log close
log using "analysis_log.log", replace text

/* â”€â”€ 1. IMPORT DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
import delimited "${filename}", clear varnames(1) stringcols(_all)

/* â”€â”€ 2. DESTRING NUMERIC VARIABLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
${numericVars.map(v => `destring ${v.name}, replace`).join('\n')}

/* â”€â”€ 3. VARIABLE LABELS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
${vars.map(v => `label variable ${v.name} "${v.name.replace(/_/g, ' ')}"`).join('\n')}

/* â”€â”€ 4. VALUE LABELS (categorical) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
${categoricalVars.map(v => {
  const vals = v.values.slice(0, 10);
  const labelDef = vals.map((val, i) => `${i+1} "${val}"`).join(' ');
  return `label define lbl_${v.name} ${labelDef}
encode ${v.name}, gen(${v.name}_cat) label(lbl_${v.name})`;
}).join('\n\n')}

/* â”€â”€ 5. MISSING DATA ASSESSMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
misstable summarize
misstable patterns

/* â”€â”€ 6. DESCRIPTIVE STATISTICS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
* Continuous variables
summarize ${numericVars.map(v => v.name).join(' ')}, detail

* Categorical variables
${categoricalVars.map(v => `tabulate ${v.name}`).join('\n')}

/* â”€â”€ 7. NORMALITY TESTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
${numericVars.slice(0, 5).map(v => `swilk ${v.name}  /* Shapiro-Wilk */`).join('\n')}

/* â”€â”€ 8. CORRELATION MATRIX â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
pwcorr ${numericVars.map(v => v.name).join(' ')}, sig star(0.05)

/* â”€â”€ 9. PRIMARY ANALYSIS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
* Logistic regression (binary outcome)
* Replace '${outcome.name}' with your binary outcome variable
logistic ${outcome.name} ${predictors.map(v => v.name).join(' ')}

* Adjusted odds ratios with 95% CI
logistic ${outcome.name} ${predictors.map(v => v.name).join(' ')}, coef
estat ic  /* AIC/BIC */
lroc      /* ROC curve */

/* â”€â”€ 10. SURVIVAL ANALYSIS (if applicable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
* Uncomment and modify as needed
/* 
stset time_variable, failure(event_variable)
sts graph, by(exposure_variable)  /* Kaplan-Meier */
stcox exposure_variable ${predictors.slice(0,3).map(v => v.name).join(' ')}
*/

/* â”€â”€ 11. PROPENSITY SCORE MATCHING (if applicable) â”€â”€â”€â”€â”€â”€â”€â”€ */
/*
teffects psmatch (${outcome.name}) (treatment_var ${predictors.map(v => v.name).join(' ')})
*/

/* â”€â”€ 12. EXPORT RESULTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
* Install and use estout for table export
* ssc install estout
* esttab using "results_table.csv", replace ci b(3) p(3)

log close
/* ============================================================
   END OF DO FILE
   ResearchFlow | researchflow-frontend-ttdz.onrender.com
   ============================================================ */`;
}

// â”€â”€ SPSS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateSPSS(vars: VarInfo[], filename: string, nRows: number): string {
  const numericVars     = vars.filter(v => v.type === 'numeric' || v.type === 'binary');
  const categoricalVars = vars.filter(v => v.type === 'categorical');
  const outcome         = vars[vars.length - 1];
  const predictors      = vars.slice(0, Math.min(5, vars.length - 1));

  return `* ============================================================
* SPSS SYNTAX â€” Generated by ResearchFlow
* Dataset: ${filename}
* Observations: ${nRows}
* Variables: ${vars.length}
* Generated: ${new Date().toLocaleDateString()}
* ============================================================.

* â”€â”€ 1. IMPORT DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€.
GET DATA /TYPE=TXT
  /FILE="${filename}"
  /ENCODING='UTF8'
  /DELIMITERS=","
  /QUALIFIER='"'
  /ARRANGEMENT=DELIMITED
  /FIRSTCASE=2
  /VARIABLES=
${vars.map(v => `    ${v.name} ${v.type === 'numeric' || v.type === 'binary' ? 'F8.2' : 'A50'}`).join('\n')}.
CACHE.
EXECUTE.

* â”€â”€ 2. VARIABLE LABELS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€.
VARIABLE LABELS
${vars.map(v => `  ${v.name} "${v.name.replace(/_/g, ' ')}"`).join('\n')}.

* â”€â”€ 3. VALUE LABELS (categorical) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€.
${categoricalVars.map(v => {
  const vals = v.values.slice(0, 10);
  return `VALUE LABELS ${v.name}
${vals.map((val, i) => `  ${i+1} "${val}"`).join('\n')}.`;
}).join('\n\n')}

* â”€â”€ 4. MISSING VALUES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€.
MISSING VALUES ALL (SYSMIS).

* â”€â”€ 5. DESCRIPTIVE STATISTICS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€.
DESCRIPTIVES VARIABLES=${numericVars.map(v => v.name).join(' ')}
  /STATISTICS=MEAN STDDEV MIN MAX VARIANCE KURTOSIS SKEWNESS.

FREQUENCIES VARIABLES=${categoricalVars.map(v => v.name).join(' ')}
  /BARCHART PERCENT
  /ORDER=ANALYSIS.

* â”€â”€ 6. NORMALITY TESTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€.
EXAMINE VARIABLES=${numericVars.slice(0,5).map(v => v.name).join(' ')}
  /PLOT BOXPLOT HISTOGRAM NPPLOT
  /STATISTICS DESCRIPTIVES
  /CINTERVAL 95
  /MISSING LISTWISE
  /NOTOTAL.

* â”€â”€ 7. CORRELATION MATRIX â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€.
CORRELATIONS
  /VARIABLES=${numericVars.map(v => v.name).join(' ')}
  /PRINT=TWOTAIL SIG NOSIG
  /MISSING=PAIRWISE.

* â”€â”€ 8. LOGISTIC REGRESSION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€.
LOGISTIC REGRESSION VARIABLES ${outcome.name}
  /METHOD=ENTER ${predictors.map(v => v.name).join(' ')}
  /PRINT=CI(95) GOODFIT ITER(1) SUMMARY
  /CRITERIA=PIN(0.05) POUT(0.10) ITERATE(20) CUT(0.5).

* â”€â”€ 9. CROSSTABULATIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€.
${categoricalVars.slice(0, 3).map(v => `CROSSTABS
  /TABLES=${outcome.name} BY ${v.name}
  /FORMAT=AVALUE TABLES
  /STATISTICS=CHISQ RISK
  /CELLS=COUNT ROW COLUMN
  /COUNT ROUND CELL.`).join('\n\n')}

* â”€â”€ 10. EXPORT RESULTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€.
* OUTPUT EXPORT
*   /CONTENTS  EXPORT=ALL  LAYERS=PRINTSETTING  MODELVIEWS=PRINTSETTING
*   /XLSX  DOCUMENTFILE="results.xlsx".

* ============================================================
* END OF SYNTAX FILE
* ResearchFlow | researchflow-frontend-ttdz.onrender.com
* ============================================================.`;
}

// â”€â”€ R â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateR(vars: VarInfo[], filename: string, nRows: number): string {
  const numericVars     = vars.filter(v => v.type === 'numeric' || v.type === 'binary');
  const categoricalVars = vars.filter(v => v.type === 'categorical');
  const outcome         = vars[vars.length - 1];
  const predictors      = vars.slice(0, Math.min(5, vars.length - 1));

  return `# ============================================================
# R SCRIPT â€” Generated by ResearchFlow
# Dataset: ${filename}
# Observations: ${nRows}
# Variables: ${vars.length}
# Generated: ${new Date().toLocaleDateString()}
# ============================================================

# â”€â”€ 1. LOAD PACKAGES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
packages <- c("tidyverse", "gtsummary", "survival", "survminer",
              "MatchIt", "tableone", "ggplot2", "rms", "Hmisc")
installed <- packages %in% rownames(installed.packages())
if (any(!installed)) install.packages(packages[!installed])
lapply(packages, library, character.only = TRUE)

# â”€â”€ 2. IMPORT DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
df <- read.csv("${filename}", stringsAsFactors = FALSE)
dim(df)        # ${nRows} rows x ${vars.length} columns
str(df)
head(df)

# â”€â”€ 3. DATA TYPES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Numeric variables
${numericVars.map(v => `df$${v.name} <- as.numeric(df$${v.name})`).join('\n')}

# Categorical variables
${categoricalVars.map(v => `df$${v.name} <- as.factor(df$${v.name})`).join('\n')}

# â”€â”€ 4. MISSING DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Summary of missing values
missing_summary <- data.frame(
  variable = names(df),
  n_missing = sapply(df, function(x) sum(is.na(x))),
  pct_missing = sapply(df, function(x) round(mean(is.na(x)) * 100, 1))
)
print(missing_summary[missing_summary$n_missing > 0, ])

# â”€â”€ 5. DESCRIPTIVE STATISTICS (Table 1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
table1 <- CreateTableOne(
  vars = c(${vars.map(v => `"${v.name}"`).join(', ')}),
  data = df
)
print(table1, showAllLevels = TRUE, formatOptions = list(big.mark = ","))

# Export Table 1
table1_df <- print(table1, quote = FALSE, noSpaces = TRUE, printToggle = FALSE)
write.csv(table1_df, "table1.csv")

# â”€â”€ 6. NORMALITY TESTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
${numericVars.slice(0,5).map(v => `shapiro.test(df$${v.name})  # ${v.name}`).join('\n')}

# â”€â”€ 7. CORRELATION MATRIX â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
numeric_df <- df[, c(${numericVars.map(v => `"${v.name}"`).join(', ')})]
cor_matrix <- cor(numeric_df, use = "complete.obs")
print(round(cor_matrix, 2))

# â”€â”€ 8. PRIMARY ANALYSIS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Logistic regression
model <- glm(
  ${outcome.name} ~ ${predictors.map(v => v.name).join(' + ')},
  data   = df,
  family = binomial(link = "logit")
)
summary(model)

# Odds Ratios with 95% CI
exp(cbind(OR = coef(model), confint(model)))

# â”€â”€ 9. PUBLICATION-READY TABLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
tbl_regression(model, exponentiate = TRUE) %>%
  add_n() %>%
  add_nevent() %>%
  bold_p() %>%
  bold_labels()

# â”€â”€ 10. SURVIVAL ANALYSIS (if applicable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Uncomment and modify as needed
# surv_obj <- Surv(time = df$time_variable, event = df$event_variable)
# km_fit   <- survfit(surv_obj ~ df$exposure_variable)
# ggsurvplot(km_fit, data = df, pval = TRUE, conf.int = TRUE,
#            xlab = "Time", ylab = "Survival probability")

# â”€â”€ 11. PROPENSITY SCORE MATCHING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Uncomment and modify as needed
# match_out <- matchit(
#   treatment ~ ${predictors.map(v => v.name).join(' + ')},
#   data   = df,
#   method = "nearest",
#   ratio  = 1
# )
# summary(match_out)
# matched_df <- match.data(match_out)

# â”€â”€ 12. SAVE RESULTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# save(df, model, file = "analysis_results.RData")

# ============================================================
# END OF R SCRIPT
# ResearchFlow | researchflow-frontend-ttdz.onrender.com
# ============================================================`;
}

const LANGS = [
  { id: 'stata', label: 'STATA',  icon: 'ðŸ“Š', color: '#1a5276', ext: 'do',  mime: 'text/plain' },
  { id: 'spss',  label: 'SPSS',   icon: 'ðŸ”µ', color: '#1f618d', ext: 'sps', mime: 'text/plain' },
  { id: 'r',     label: 'R',      icon: 'ðŸ”µ', color: '#276dc3', ext: 'R',   mime: 'text/plain' },
];

export default function SyntaxExporter() {
  const [vars, setVars]         = useState<VarInfo[]>([]);
  const [filename, setFilename] = useState('');
  const [nRows, setNRows]       = useState(0);
  const [activeLang, setActiveLang] = useState('stata');
  const [copied, setCopied]     = useState(false);
  const [outcome, setOutcome]   = useState('');
  const [loading, setLoading]   = useState(false);

  function handleUpload(e: React.ChangeEvent<HTMLInputElement>) {
    const file = e.target.files?.[0];
    if (!file) return;
    setLoading(true);
    setFilename(file.name);
    const reader = new FileReader();
    reader.onload = (ev) => {
      const text = ev.target?.result as string;
      const { headers, rows } = parseCSV(text);
      setNRows(rows.length);
      const varInfos = buildVarInfo(headers, rows);
      setVars(varInfos);
      setOutcome(varInfos[varInfos.length - 1].name);
      setLoading(false);
    };
    reader.readAsText(file);
  }

  function getSyntax() {
    const orderedVars = outcome
      ? [...vars.filter(v => v.name !== outcome), vars.find(v => v.name === outcome)!]
      : vars;
    if (activeLang === 'stata') return generateSTATA(orderedVars, filename, nRows);
    if (activeLang === 'spss')  return generateSPSS(orderedVars, filename, nRows);
    return generateR(orderedVars, filename, nRows);
  }

  function copySyntax() {
    navigator.clipboard.writeText(getSyntax());
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  }

  function downloadSyntax() {
    const lang = LANGS.find(l => l.id === activeLang)!;
    const blob = new Blob([getSyntax()], { type: lang.mime });
    const url  = URL.createObjectURL(blob);
    const a    = document.createElement('a');
    a.href = url;
    a.download = `analysis_${filename.replace('.csv','')}.${lang.ext}`;
    a.click();
  }

  return (
    <div className="page">
      <h1 style={{ color: '#1C2B3A' }}>Export Analysis Syntax</h1>
      <p style={{ marginBottom: '1.5rem' }}>
        Upload your dataset and auto-generate analysis code for STATA, SPSS or R â€” ready to run.
      </p>

      {!vars.length && (
        <div className="card" style={{ maxWidth: 500 }}>
          <h2>Upload Dataset</h2>
          <label className="upload-zone" style={{ display: 'block', cursor: 'pointer' }}>
            <div style={{ fontSize: '2rem', marginBottom: '0.5rem' }}>ðŸ“‚</div>
            <p style={{ fontWeight: 600, color: '#1C2B3A' }}>Upload CSV file</p>
            <p style={{ fontSize: '0.85rem' }}>Syntax auto-generated for all variables</p>
            <input type="file" accept=".csv" onChange={handleUpload} style={{ display: 'none' }} />
          </label>
          {loading && <p style={{ textAlign: 'center', color: '#888', marginTop: '1rem' }}>Generating syntax...</p>}
        </div>
      )}

      {vars.length > 0 && (
        <div>
          {/* HEADER */}
          <div style={{ display: 'flex', gap: '1rem', marginBottom: '1.5rem', flexWrap: 'wrap', alignItems: 'center' }}>
            <div style={{ flex: 1, minWidth: 200 }}>
              <label style={{ fontSize: '0.78rem', fontWeight: 700, color: '#888', display: 'block', marginBottom: 4 }}>OUTCOME VARIABLE</label>
              <select value={outcome} onChange={e => setOutcome(e.target.value)}
                style={{ width: '100%', padding: '0.6rem', borderRadius: 8, border: '1px solid #ccc', fontSize: '0.88rem' }}>
                {vars.map(v => <option key={v.name} value={v.name}>{v.name}</option>)}
              </select>
            </div>
            <label className="btn" style={{ background: '#eee', color: '#444', cursor: 'pointer', alignSelf: 'flex-end' }}>
              Upload New
              <input type="file" accept=".csv" onChange={handleUpload} style={{ display: 'none' }} />
            </label>
          </div>

          {/* LANGUAGE TABS */}
          <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem' }}>
            {LANGS.map(lang => (
              <button key={lang.id} onClick={() => setActiveLang(lang.id)} style={{
                padding: '0.6rem 1.5rem', borderRadius: 8, border: 'none', cursor: 'pointer', fontWeight: 700, fontSize: '0.9rem',
                background: activeLang === lang.id ? lang.color : '#eee',
                color: activeLang === lang.id ? 'white' : '#444',
                transition: 'all 0.2s',
              }}>
                {lang.icon} {lang.label}
              </button>
            ))}
            <div style={{ flex: 1 }} />
            <button className="btn btn-sage" onClick={copySyntax} style={{ fontSize: '0.85rem' }}>
              {copied ? 'âœ“ Copied!' : 'ðŸ“‹ Copy'}
            </button>
            <button className="btn btn-primary" onClick={downloadSyntax} style={{ fontSize: '0.85rem' }}>
              â¬‡ï¸ Download .{LANGS.find(l => l.id === activeLang)?.ext}
            </button>
          </div>

          {/* SYNTAX DISPLAY */}
          <div style={{ background: '#1e1e2e', borderRadius: 12, overflow: 'hidden', boxShadow: '0 4px 20px rgba(0,0,0,0.2)' }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '0.75rem 1.25rem', background: '#13131f', borderBottom: '1px solid #333' }}>
              <div style={{ display: 'flex', gap: '0.4rem' }}>
                {['#ff5f57','#febc2e','#28c840'].map(c => (
                  <div key={c} style={{ width: 12, height: 12, borderRadius: '50%', background: c }} />
                ))}
              </div>
              <span style={{ color: '#888', fontSize: '0.78rem' }}>
                {filename} â€” {LANGS.find(l => l.id === activeLang)?.label} syntax
              </span>
              <span style={{ color: '#888', fontSize: '0.78rem' }}>{vars.length} variables</span>
            </div>
            <pre style={{ padding: '1.5rem', color: '#e0e0e0', fontSize: '0.82rem', lineHeight: 1.7, overflowX: 'auto', margin: 0, maxHeight: '70vh', overflowY: 'auto' }}>
              <code>{getSyntax()}</code>
            </pre>
          </div>

          {/* TIPS */}
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3,1fr)', gap: '1rem', marginTop: '1.5rem' }}>
            {[
              { icon: 'ðŸ“Š', title: 'STATA Tips', color: '#1a5276', tips: ['Run do file: do analysis.do', 'Check log file for output', 'Edit variable labels as needed', 'Add your ethics number to header'] },
              { icon: 'ðŸ”µ', title: 'SPSS Tips',  color: '#1f618d', tips: ['Open syntax editor: File â†’ New â†’ Syntax', 'Select all and Run', 'Edit value labels for your coding', 'Output to .xlsx for reporting'] },
              { icon: 'ðŸ”µ', title: 'R Tips',     color: '#276dc3', tips: ['Set working directory first', 'Install packages if needed', 'Use RMarkdown for reproducibility', 'gtsummary for publication tables'] },
            ].map(lang => (
              <div key={lang.title} className="card" style={{ borderTop: `4px solid ${lang.color}` }}>
                <h3 style={{ color: lang.color, fontSize: '0.9rem', marginBottom: '0.75rem' }}>{lang.icon} {lang.title}</h3>
                {lang.tips.map((tip, i) => (
                  <p key={i} style={{ fontSize: '0.78rem', color: '#555', marginBottom: '0.3rem', display: 'flex', gap: '0.4rem' }}>
                    <span style={{ color: lang.color }}>â†’</span> {tip}
                  </p>
                ))}
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
